import os
import re
import shutil
import yaml
from deepdiff import DeepDiff

# === Configure paths (use raw strings r"" on Windows) ===
input_dir               = r"C:\Users\iqahmad\Desktop\RFP\GitHubRepo\ucd-to-harness1\harness_out_RG1\.harness\services"
pair_reports_dir        = r"C:\Users\iqahmad\Desktop\RFP\GitHubRepo\ucd-to-harness1\yaml_diffs_recursive"
matching_common_folder  = r"C:\Users\iqahmad\Desktop\RFP\GitHubRepo\ucd-to-harness1\yaml_matching_common"

# === Matching strategy ===
# "exact": copy files only when YAMLs are identical (DeepDiff == empty, ignore_order=True)
# "threshold": use similarity of flattened keypaths & values
MATCH_MODE = "exact"          # choose: "exact" or "threshold"
SIMILARITY_THRESHOLD = 0.90   # used only when MATCH_MODE == "threshold"

# ---------- helpers ----------

def ensure_dir(path: str):
    os.makedirs(path, exist_ok=True)

def list_yaml_files_recursively(root_dir: str):
    files = []
    for root, _, filenames in os.walk(root_dir):
        for name in filenames:
            if name.lower().endswith((".yaml", ".yml")):
                full = os.path.join(root, name)
                rel  = os.path.relpath(full, root_dir)
                files.append((full, rel))  # (absolute_path, relative_path)
    return files

def load_first_yaml_doc(path: str):
    # Compare the first document if a file contains multiple docs separated by '---'
    with open(path, "r", encoding="utf-8") as f:
        docs = list(yaml.safe_load_all(f))
        if not docs:
            return {}
        return docs[0] if docs[0] is not None else {}

def flatten(obj, path=()):
    """
    Flatten dicts/lists into {"a.b[0].c": value, ...} for path-wise equality & similarity.
    """
    if isinstance(obj, dict):
        for k, v in obj.items():
            yield from flatten(v, path + (str(k),))
    elif isinstance(obj, list):
        for i, v in enumerate(obj):
            yield from flatten(v, path + (f"[{i}]",))
    else:
        yield (".".join(path), obj)

def sane_name(s: str) -> str:
    """
    Safe filename from a relative path (keep dot, dash, underscore).
    """
    s = s.replace(os.sep, "__")
    return re.sub(r"[^A-Za-z0-9._-]+", "_", s)

def similarity(flat1: dict, flat2: dict) -> float:
    """
    Jaccard-like similarity on exact (path,value) matches.
    score = |intersection| / |union|
    """
    set1 = set(flat1.items())
    set2 = set(flat2.items())
    if not set1 and not set2:
        return 1.0
    union = set1 | set2
    inter = set1 & set2
    return len(inter) / len(union) if union else 0.0

# ---------- main ----------

def main():
    ensure_dir(pair_reports_dir)
    ensure_dir(matching_common_folder)

    yaml_files = list_yaml_files_recursively(input_dir)
    if len(yaml_files) < 2:
        print("Need at least two YAML files under input_dir to compare.")
        return

    files_to_copy = set()
    total_pairs = 0
    written_reports = 0
    matched_pairs = 0

    for i in range(len(yaml_files)):
        for j in range(i + 1, len(yaml_files)):
            total_pairs += 1
            path1, rel1 = yaml_files[i]
            path2, rel2 = yaml_files[j]

            data1 = load_first_yaml_doc(path1) or {}
            data2 = load_first_yaml_doc(path2) or {}

            # Deep diff (structure-aware; ignores list order)
            diff = DeepDiff(data1, data2, ignore_order=True)

            # Matching by mode
            flat1 = dict(flatten(data1))
            flat2 = dict(flatten(data2))
            matches = {k: v for k, v in flat1.items() if k in flat2 and flat2[k] == v}
            sim = similarity(flat1, flat2)

            if MATCH_MODE == "exact":
                is_match = (not diff)  # exact structural match
            else:  # threshold mode
                is_match = (sim >= SIMILARITY_THRESHOLD)

            if is_match:
                matched_pairs += 1
                files_to_copy.add(path1)
                files_to_copy.add(path2)

            # Write pair report
            out_name = f"compare_{sane_name(rel1)}_vs_{sane_name(rel2)}.txt"
            out_path = os.path.join(pair_reports_dir, out_name)
            with open(out_path, "w", encoding="utf-8") as f:
                f.write("=== YAML Comparison ===\n")
                f.write(f"File A: {rel1}\n")
                f.write(f"File B: {rel2}\n")
                f.write(f"Match mode: {MATCH_MODE}\n")
                if MATCH_MODE == "threshold":
                    f.write(f"Similarity: {sim:.3f}  (threshold={SIMILARITY_THRESHOLD:.2f})\n")
                f.write(f"Pair considered MATCH: {is_match}\n\n")

                f.write("✅ Matching values (same path & value):\n")
                if matches:
                    for k in sorted(matches):
                        f.write(f"  {k}: {matches[k]!r}\n")
                else:
                    f.write("  (none)\n")

                f.write("\n❌ Differences (DeepDiff, ignore_order=True):\n")
                if diff:
                    f.write(str(diff) + "\n")
                else:
                    f.write("  (none)\n")

            written_reports += 1

    # Copy unique matched files to the common folder (avoid overwrites with safe names)
    copied = 0
    for src in sorted(files_to_copy):
        rel = os.path.relpath(src, input_dir)
        safe = sane_name(rel)
        dst = os.path.join(matching_common_folder, safe)
        # Preserve extension; if missing, default to .yaml
        if not os.path.splitext(dst)[1]:
            dst += ".yaml"
        shutil.copy2(src, dst)
        copied += 1

    print(f"Done.\n  Compared pairs: {total_pairs}\n  Reports written: {written_reports} -> {pair_reports_dir}")
    print(f"  Matching pairs: {matched_pairs}")
    print(f"  Unique files copied to common folder: {copied} -> {matching_common_folder}")

if __name__ == "__main__":
    main()
